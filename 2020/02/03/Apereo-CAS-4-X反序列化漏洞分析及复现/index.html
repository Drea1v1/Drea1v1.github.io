<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Apereo CAS 4.X反序列化漏洞分析及复现 · 认真学习的小白帽</title><meta name="description" content="Apereo CAS 4.X反序列化漏洞分析及复现 - Drea1v1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://drea1v1.github.io/atom.xml" title="认真学习的小白帽"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="认真学习的小白帽" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">认真学习的小白帽</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/Drea1v1" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Apereo CAS 4.X反序列化漏洞分析及复现</h1><div class="post-info">Feb 3, 2020</div><div class="post-content"><h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>放假前看到很多文章对这个漏洞进行分析复现，又因为过年期间的特殊情况，实在是无聊至极，所以自己也来学习一下，顺便恶补一下反序列化漏洞的知识。这篇文章记录了自己的一些想法以及相关的知识点，方便自己日后忘记可以重新拾起。第一次写文章有不好的，希望大家见谅。</p>
<h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>由于部分cas版本的加密函数不同有相应的变化，因此想要按照此文章来复现漏洞的话还是选择和我一样的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk8u144(不一定完全一样)</span><br><span class="line">ApereoCas-4.1.5</span><br></pre></td></tr></table></figure>


<hr>
<blockquote>
<p>下载CAS-Overlay-Template</p>
</blockquote>
<p>github链接(<a href="https://github.com/apereo/cas-overlay-template/tree/4.1" target="_blank" rel="noopener">https://github.com/apereo/cas-overlay-template/tree/4.1</a>)</p>
<p>github上有详细的部署操作，这里要注意要修改pom.xml文件cas的版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cas.version&gt;4.1.5&lt;&#x2F;cas.version&gt;</span><br></pre></td></tr></table></figure>
<p>编译完后，会在target目录生成一个cas.war的war包，将该war包放在tomcat的web目录上，启动tomcat即可通过<a href="http://localhost/cas" target="_blank" rel="noopener">http://localhost/cas</a>访问example。</p>
<p>成功部署后：<br><img src="/images/ApereoCas/1.jpg" alt="image"></p>
<h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>该漏洞存在于登录的execution参数，抓包发现该参数值应该是加密过的，故要知道对应的加密方法以及处理过程才行。</p>
<p><img src="/images/ApereoCas/2.jpg" alt="image"></p>
<blockquote>
<p>web.xml</p>
</blockquote>
<p>查看登录url对应的servlet可知道交给了Spring的DispatcherServlet处理了，配置文件为/WEB-INF/cas-servlet.xml<br><img src="/images/ApereoCas/3.jpg" alt="image"></p>
<p>从springmvc的执行流程图(网上找的)可以知道只要找到对应的处理器适配器，就能找到对应的处理器。<br><img src="/images/ApereoCas/4.jpg" alt="image"></p>
<blockquote>
<p>cas-servlet.xml</p>
</blockquote>
<p>全局搜索login字眼，看到loginHandlerAdapter适配器，处理器的类名为org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter</p>
<p><img src="/images/ApereoCas/5.jpg" alt="image"></p>
<p>org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter该类继承FlowHandlerAdapter类，登录时调用继承类的handler方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter#handle</span><br><span class="line"></span><br><span class="line">public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        FlowHandler flowHandler &#x3D; (FlowHandler)handler;</span><br><span class="line">        this.checkAndPrepare(request, response, false);</span><br><span class="line">        String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br><span class="line">        if (flowExecutionKey !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.resumeExecution(flowExecutionKey, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var11) &#123;</span><br><span class="line">                this.handleFlowException(var11, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String flowId &#x3D; this.getFlowId(flowHandler, request);</span><br><span class="line">                MutableAttributeMap&lt;Object&gt; input &#x3D; this.getInputMap(flowHandler, request);</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.launchExecution(flowId, input, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var10) &#123;</span><br><span class="line">                this.handleFlowException(var10, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>其中flowExecutionKey通过getFlowExecutionKey方法获取参数execution的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br></pre></td></tr></table></figure>
<p>flowExecutionKey作为参数传入resumeExecution方法，跟进函数。在第91行对flowExecutionKey值的格式进行判断，通过”-“分割字符串为两部分uuid以及base64编码flowstate，因此格式不满足的话是无法继续走下去的。</p>
<p><img src="/images/ApereoCas/6.jpg" alt="image"></p>
<p><img src="/images/ApereoCas/7.jpg" alt="image"></p>
<p>跟进第96行getFlowExecution。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public FlowExecution getFlowExecution(FlowExecutionKey key) throws FlowExecutionRepositoryException &#123;</span><br><span class="line">        if (!(key instanceof ClientFlowExecutionKey)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Expected instance of ClientFlowExecutionKey but got &quot; + key.getClass().getName());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte[] encoded &#x3D; ((ClientFlowExecutionKey)key).getData();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ClientFlowExecutionRepository.SerializedFlowExecutionState state &#x3D; (ClientFlowExecutionRepository.SerializedFlowExecutionState)this.transcoder.decode(encoded);</span><br><span class="line">                FlowDefinition flow &#x3D; this.flowDefinitionLocator.getFlowDefinition(state.getFlowId());</span><br><span class="line">                return this.flowExecutionFactory.restoreFlowExecution(state.getExecution(), flow, key, state.getConversationScope(), this.flowDefinitionLocator);</span><br><span class="line">            &#125; catch (IOException var5) &#123;</span><br><span class="line">                throw new ClientFlowExecutionRepositoryException(&quot;Error decoding flow execution&quot;, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在第105行对之前base64解码后的encoded进行解密，跟进解密函数this.transcoder.decode(encoded)</p>
<p><img src="/images/ApereoCas/8.jpg" alt="image"></p>
<p><img src="/images/ApereoCas/9.jpg" alt="image"></p>
<p>可以看出在第83行对密文进行解密，经过一系列的操作后在99行进行反序列化，触发漏洞。可以看出调用的decode方法属于EncryptedTranscoder类，该类还定义的加密方法encode，这里可以直接生成恶意对象，直接调用org.jasig.spring.webflow.plugin.EncryptedTranscoder#encode生成加密字节数组后base64，加上”uuid-“构成execution的值。</p>
<blockquote>
<p>整个调用栈</p>
</blockquote>
<p><img src="/images/ApereoCas/10.jpg" alt="image"></p>
<h1 id="0x03-构造payload"><a href="#0x03-构造payload" class="headerlink" title="0x03 构造payload"></a>0x03 构造payload</h1><p>默认环境的jar包中有commons-collections4-4.0.jar，直接使用ysoserial生成payload,这里记得要将payload的特殊符号进行url编码。</p>
<p><img src="/images/ApereoCas/11.jpg" alt="image"></p>
<p><img src="/images/ApereoCas/12.jpg" alt="image"></p>
<blockquote>
<p>演示结果</p>
</blockquote>
<p>成功执行系统命令<br><img src="/images/ApereoCas/13.jpg" alt="image"></p>
<h1 id="0x04-构造回显payload"><a href="#0x04-构造回显payload" class="headerlink" title="0x04 构造回显payload"></a>0x04 构造回显payload</h1><p>看了大佬的<a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">分析</a>，知道可以回显，文章提及到org.springframework.webflow.context.ExternalContextHolder.getExternalContext()方法可以获取到上下文关联信息，然后通过getNativeRequest()方法获取request对象通过getNativeResponse()方法获取response对象。同时提及到org.springframework.cglib.core.ReflectUtils.defineClass().newInstance();加载payload。我的猜测大佬的想法是通过defineClass从byte[]还原出一个Class对象，该恶意对象主要是执行命令，获取response对象，将执行命令后的结果通过response对象的输出流输出。在利用commons-collections1是发现ReflectUtils利用不了，因为构造方法为private，要设置setAccessible为true。因此使用commons-collections2的话，实际就不需要这么麻烦用defineClass来加载payload了，直接在利用类里面写就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils</span><br><span class="line">private ReflectUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils#defineClass</span><br><span class="line"></span><br><span class="line"> public static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception &#123;</span><br><span class="line">        Object[] args &#x3D; new Object[]&#123;className, b, new Integer(0), new Integer(b.length), PROTECTION_DOMAIN&#125;;</span><br><span class="line">        Class c &#x3D; (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">        Class.forName(className, true, loader);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里看看ysoserial的commons-collections2的构造恶意对象的主要方法。这里使用javassist,第66行获取要操作的类，第75行在该类的构造方法中插入代码,因此这里只要修改该类ysoserial.payloads.util.Gadgets.StubTransletPayload的构造方法为执行系统命令，并修改response的输出流。大家可以直接修改ysoserial的源码并重新编译，我这里为了方便直接用了网上的payload改了一下。</p>
<p><img src="/images/ApereoCas/14.jpg" alt="image"></p>
<p><img src="/images/ApereoCas/15.jpg" alt="image"></p>
<blockquote>
<p>演示结果</p>
</blockquote>
<p><img src="/images/ApereoCas/16.jpg" alt="image"></p>
<h1 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h1><p>文章中存在错误的地方希望大佬们斧正，多多指点。通过这次的分析，其实学到很多东西的，包括commons-collections利用链、ysoserial(这个工具，也是边看别人的分析，边看的源码，不然一脸懵逼)。最后，在新的一年里希望大家身体健康，万事如意。</p>
<h1 id="0x05参考链接："><a href="#0x05参考链接：" class="headerlink" title="0x05参考链接："></a>0x05参考链接：</h1><p><a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">https://www.00theway.org/2020/01/04/apereo-cas-rce/</a></p>
<p><a href="https://xz.aliyun.com/t/2041" target="_blank" rel="noopener">https://xz.aliyun.com/t/2041</a></p>
<p><a href="https://xz.aliyun.com/t/4711" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711</a></p>
<p><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">https://xz.aliyun.com/t/7031</a></p>
<p><a href="https://xz.aliyun.com/t/7032" target="_blank" rel="noopener">https://xz.aliyun.com/t/7032</a></p>
<p><a href="http://www.vuln.cn/6295" target="_blank" rel="noopener">http://www.vuln.cn/6295</a></p>
<p><a href="https://www.freebuf.com/vuls/170344.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/170344.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA</a></p>
<p><a href="https://www.cnblogs.com/gxc6/p/9544563.html" target="_blank" rel="noopener">https://www.cnblogs.com/gxc6/p/9544563.html</a></p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2020/06/17/%E7%94%A8%E5%8F%8Bnc%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="prev">PREV</a></div><div class="copyright"><p>© 2020 <a href="https://drea1v1.github.io">Drea1v1</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>