<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用友nc远程命令执行漏洞分析 · 认真学习的小白帽</title><meta name="description" content="用友nc远程命令执行漏洞分析 - Drea1v1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://drea1v1.github.io/atom.xml" title="认真学习的小白帽"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="认真学习的小白帽" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">认真学习的小白帽</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/Drea1v1" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">用友nc远程命令执行漏洞分析</h1><div class="post-info">Jun 17, 2020</div><div class="post-content"><h1 id="NC用友远程命令执行漏洞分析"><a href="#NC用友远程命令执行漏洞分析" class="headerlink" title="NC用友远程命令执行漏洞分析"></a>NC用友远程命令执行漏洞分析</h1><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>这个漏洞是<a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener"> 国家电网公司信息与网络安全重点实验室 </a>发现的，微信公众号做了简要分析，但是没有给出具体的poc。现在微信公众号已经将文章删除，但其他的安全公众号仍留有记录，看了一下分析过程，故想要跟着分析漏洞成因，编写poc，因此才有了这一篇分析文章。虽然此次漏洞公告上写的版本为NC6.5,但是实际上像较新版的1909 NCCloud(用友2018年11月发布的最新技术架构软件)等都是存在该漏洞的。</p>
<h2 id="0x01分析过程"><a href="#0x01分析过程" class="headerlink" title="0x01分析过程"></a>0x01分析过程</h2><h3 id="1-客户端分析"><a href="#1-客户端分析" class="headerlink" title="1.客户端分析"></a>1.客户端分析</h3><p>访问<code>http://ip:port/index.jsp</code>会提示有两种方法登录系统，一种是通过下载客户端、一种是使用浏览器访问。因为，浏览器访问的方式需要依赖不同用户设备上的java版本，IE浏览器，系统配置等环境因素，使用起来不是很方便，所以为了解决这些问题，用友提供了系统专用的UClient浏览器，可直接通过该浏览器访问nc而无需安装配置任意东西。</p>
<p><img src="/images/YonyouNc/1592135084333.png" alt="1592135084333"></p>
<p>下载NClient并安装后，进入启动页面，可以选择<strong><u>添加应用</u></strong>。添加完后，在安装目录中可以看到所安装的应用。</p>
<p><img src="/images/YonyouNc/1592135683158.png" alt="1592135683158"></p>
<p><img src="/images/YonyouNc/1592135763897.png" alt="1592135763897"></p>
<p>点击app.esc发现直接启动了nc客户端，查看文件内容，发现执行了NClogin65.jar文件中的nc.starter.test.JStarter：</p>
<p><img src="/images/YonyouNc/1592136037372.png" alt="1592136037372"></p>
<p>反编译NClogin65.jar，查看nc.starter.test.JStarter，调用nc.starter.ui.NCLauncher#main主要是与远程服务端通信，生成uI之类的操作。主要的通信代码并不在该jar包，继续在目录中寻找。</p>
<p><img src="/images/YonyouNc/1592136244643.png" alt="1592136244643"></p>
<p><img src="/images/YonyouNc/1592136335295.png" alt="1592136335295"></p>
<p>在nc_client_home\NCCACHE\CODE目录的子目录中有很多的jar包，其中external目录上的jar包是客户端通信的逻辑代码。</p>
<p><img src="/images/YonyouNc/1592136581135.png" alt="1592136581135"></p>
<p>随便点了一两个包，发现类还不少，如果逐个看的话很耗费时间，效率还不高，看了分析的文章发现用javaagent把调用的类都打印出来的方法可以解决这个问题，具体原理感兴趣的可以去网上搜索相关的文章，具体可以代码可以参考<a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">javaagent项目中使用</a>。</p>
<p>之前在app.esc文件中可以看到启动jar的jvm配置信息，加上我们的javaagent的jar包，这样才能正常加载自己的javaagent。</p>
<p><img src="/images/YonyouNc/1592137794616.png" alt="1592137794616"></p>
<p>启动后可以看到把所有调用的类都输出出来了。</p>
<p><img src="/images/YonyouNc/1592137667520.png" alt="1592137667520"></p>
<p>这里可以配合idea的远程调试，添加参数jdwp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,address&#x3D;8000</span><br></pre></td></tr></table></figure>

<p><img src="/images/YonyouNc/1592151755174.png" alt="1592151755174"></p>
<p>打开客户端，随便输入账号密码点击登录后，查看log可以看到有login字眼的类：</p>
<p><img src="/images/YonyouNc/1592151973097.png" alt="1592151973097"></p>
<p>找到对应的nc.login.ui.LoginUISupport类，这个类方法很多，我一开始想的是通过一般登录都是带有request，response的，所以我就搜了request的关键字，在一个看起来比较像处理登录请求的方法下了断点，点击登录后果然是在这个地方断下来了。该方法主要是将输入的用户名、密码等值，在requestd类的变量赋值。</p>
<p><img src="/images/YonyouNc/1592152447890.png" alt="1592152447890"></p>
<p>执行getInstance(),获取NCLocator的实例，并执行实例的lookup方法。</p>
<p><img src="/images/YonyouNc/1592203909575.png" alt="1592203909575"></p>
<p>跟进<code>nc.bs.framework.common.NCLocator#getInstance(java.util.Properties)</code></p>
<p><img src="/images/YonyouNc/1592204019467.png" alt="1592204019467"></p>
<p>刚启动的时候locatorMap为空，则会在下面的判断分支中，创建RmiNCLocator实例并将该实例存放到locatorMap中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">locator = (NCLocator)locatorMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (locator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(locatorProvider)) &#123;</span><br><span class="line">                locator = newInstance(locatorProvider);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isEmpty(svcDispatchURL)) &#123;</span><br><span class="line">                locator = newInstance(<span class="string">"nc.bs.framework.rmi.RmiNCLocator"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                locator = getDefaultLocator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            locator.init(props);</span><br><span class="line">            locatorMap.put(key, locator);</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>获取到RmiNCLocator实例后，跟进到lookup方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RmiNCLocator#lookup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> ComponentException </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.remoteContext.lookup(name);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var4 <span class="keyword">instanceof</span> FrameworkRuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (FrameworkRuntimeException)var4;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentException(name, <span class="string">"Component resolve exception "</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>this.remoteContext.lookup(name);</code>,继续跟进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteContextStub#lookup</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object so = <span class="keyword">this</span>.proxyMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> so;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ComponentMetaVO metaVO = <span class="keyword">this</span>.getMetaOnDemand(name);</span><br><span class="line">            <span class="keyword">if</span> (metaVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentNotFoundException(name, <span class="string">"no remote componnet found from server"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                so = <span class="keyword">this</span>.proxyMap.get(metaVO.getName());</span><br><span class="line">                <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    RemoteAddressSelector ras = <span class="keyword">new</span> GroupBasedRemoteAddressSelector(<span class="keyword">this</span>.getRealTarget(metaVO), <span class="keyword">this</span>.getServerGroup(metaVO));</span><br><span class="line">                    so = RemoteProxyFactory.getDefault().createRemoteProxy(RemoteContextStub<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">metaVO</span>, <span class="title">ras</span>)</span>;</span><br><span class="line">                    <span class="keyword">this</span>.proxyMap.put(metaVO.getName(), so);</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到先从proxyMap中查看是否存在参数name的方法，如果存在则直接返回，不存在则进入另外的分支。因为这里我是刚启动的，所以该方法是不存在的，也可以直接将so赋值为null，进去到下面的分支去看看具体的执行流程。</p>
<p><img src="/images/YonyouNc/1592209159419.png" alt="1592209159419"></p>
<p>跟进<code>nc.bs.framework.rmi.RemoteContextStub#getMetaOnDemand</code>,又可以看到调用了<code>this.remoteMetaContext.lookup(name);</code>方法，这个变量remoteMetaContext是<code>nc.bs.framework.server.RemoteMetaContext</code>类，那么这个类是怎么来的呢？</p>
<p><img src="/images/YonyouNc/1592209487982.png" alt="1592209487982"></p>
<p>因为当前的类为<code>nc.bs.framework.rmi.RemoteContextStub#RemoteContextStub</code>，这里可以回到类构造函数，第65行创建了一个代理，并赋值到<code>this.remoteMetaContext</code>：</p>
<p><img src="/images/YonyouNc/1592212049147.png" alt="1592212049147"></p>
<p>了解过java代理的应该知道，不管用户调用代理对象的任何方法，该方法都会调用处理器的invoke方法，这里即是<code>nc.bs.framework.rmi.RemoteInvocationHandler#invoke</code>。不懂的可以先看<a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">这里</a>。</p>
<p><img src="/images/YonyouNc/1592217600559.png" alt="1592217600559"></p>
<p>那么现在回到上面，跟进<code>this.remoteMetaContext.lookup(name);</code>，果然进入到了invoke方法。经过一番判断</p>
<p>执行this.sendRequest(method, args)方法。</p>
<p><img src="/images/YonyouNc/1592218223159.png" alt="1592218223159"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteInvocationHandler#sendRequest(java.lang.reflect.Method, java.lang.Object[])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        InvocationInfo ii = <span class="keyword">this</span>.newInvocationInfo(method, args);</span><br><span class="line">        Address old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        ConnectorFailException error = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Address target = <span class="keyword">this</span>.ras.select();</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logger.error(<span class="string">"connect to: "</span> + old + <span class="string">" failed, now retry connect to: "</span> + target);</span><br><span class="line">                <span class="keyword">if</span> (old.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">this</span>.retryInterval);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.restoreToken(ii, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var8 = <span class="keyword">this</span>.sendRequest(target, ii, method, args);</span><br><span class="line">                <span class="keyword">return</span> var8;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectorFailException var14) &#123;</span><br><span class="line">                ++retry;</span><br><span class="line">                old = target;</span><br><span class="line">                error = var14;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.storeToken(ii, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(retry &lt; <span class="keyword">this</span>.retryMax);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>this.sendRequest(target, ii, method, args);</code>,在第182行将ii序列化输出，发送到<code>http://server:port/ServiceDispatcherServlet</code>，并获取服务端返回的结果反序列化，回显到客户端。</p>
<p><img src="/images/YonyouNc/1592219243047.png" alt="1592219243047"></p>
<p><img src="/images/YonyouNc/1592219210083.png" alt="1592219210083"></p>
<p>到此客户端的处理流程大致分析完成，看到这里大家可能有会对上面客户端将类序列化发往服务端，那服务端肯定要反序列化呀，会不会有问题？别急，继续往下看。</p>
<h3 id="2-服务端分析"><a href="#2-服务端分析" class="headerlink" title="2.服务端分析"></a>2.服务端分析</h3><p>先来分析jndi注入的形成</p>
<p>在<code>nc.bs.framework.comn.serv.CommonServletDispatcher#doPost</code>第38行下断点。</p>
<p><img src="/images/YonyouNc/1592236432591.png" alt="1592236432591"></p>
<p>跟进<code>this.rmiHandler.handle(new HttpRMIContext(request, response));</code>,跟进后在第85行继续跟进<code>this.doHandle(rmiCtx);</code>。</p>
<p><img src="/images/YonyouNc/1592236486535.png" alt="1592236486535"></p>
<p>在第153行出现处理客户端提交内容的，继续跟进：</p>
<p><img src="/images/YonyouNc/1592236605328.png" alt="1592236605328"></p>
<p>在第282行可以看到直接将输入流的内容反序列化了，代码执行过程中完全没有任何的过滤，确实存在触发反序列化漏洞，这里先不管，继续往下。</p>
<p><img src="/images/YonyouNc/1592236746588.png" alt="1592236746588"></p>
<p>这里注意的是第286行将反序列化后的类赋予到抽象类<code>nc.bs.framework.rmi.server.AbstractRMIContext#invInfo</code>的invInfo变量里，这个变量在下面用到。</p>
<p><img src="/images/YonyouNc/1592220689757.png" alt="1592220689757"></p>
<p>回到刚才的第二个断点，跟进<code>result.result = this.invokeBeanMethod(rmiCtx);</code>,这里第333行就是上面说到的invinfo变量，实际就是反序列化后的类。</p>
<p>这里有两个分支，不管是哪个都存在jndi注入，因为这里lookup的参数service是可控的，所以必然存在漏洞。</p>
<p><img src="/images/YonyouNc/1592320624956.png" alt="1592320624956"></p>
<h3 id="3-效果演示"><a href="#3-效果演示" class="headerlink" title="3.效果演示"></a>3.效果演示</h3><p>这里就不给poc了，如果看懂了上面的过程其实也不难，实际就是构造一个InvocationInfo类，并将servicename的值设置为远程恶意类，序列化后发送到服务端触发jndi注入即可。</p>
<p><img src="/images/YonyouNc/1592322620367.png" alt="1592322620367"></p>
<p><img src="/images/YonyouNc/image-20200617093259154.png" alt="image-20200617093259154"></p>
<p><img src="/images/YonyouNc/1592323482077.png" alt="1592323482077"></p>
<h3 id="4-前面的反序列化"><a href="#4-前面的反序列化" class="headerlink" title="4.前面的反序列化"></a>4.前面的反序列化</h3><p>上面发现的反序列化根本都没有过滤的，为啥还要这么麻烦要jndi注入呢，直接反序列化不香嘛？看了web的依赖环境，commons-collections3.2，那不是现成的利用嘛。</p>
<p><img src="/images/YonyouNc/image-20200617105253981.png" alt="image-20200617105253981"></p>
<p>直接ysoserial生成恶意类发送，弹计算器。</p>
<p><img src="/images/YonyouNc/1592236873117.png" alt="1592236873117"></p>
<p>整个调用栈如下:</p>
<p><img src="/images/YonyouNc/image-20200617105315331.png" alt="image-20200617105315331"></p>
<p>注：在NCCloud 1909的版本中该依赖包为较新版，此利用链不可用。</p>
<h2 id="0X02-最后说几句"><a href="#0X02-最后说几句" class="headerlink" title="0X02 最后说几句"></a>0X02 最后说几句</h2><p>漏洞过程并不是太复杂，应该不难理解的。实际上，用友NC系统多处存在未过滤的反序列化漏洞，不过由于新版NC将依赖版本更新了，yso的大多数利用链都不能使用了,因此需要重新寻找新的利用链。</p>
<h2 id="0X03参考链接"><a href="#0X03参考链接" class="headerlink" title="0X03参考链接"></a>0X03参考链接</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA</a> </li>
<li><a href="https://nosec.org/home/detail/4472.html" target="_blank" rel="noopener">https://nosec.org/home/detail/4472.html</a></li>
<li><a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">https://www.cnblogs.com/Java-Script/p/11089314.html</a></li>
<li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a></li>
<li><a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3971367.html</a></li>
<li><a href="https://www.anquanke.com/post/id/208726" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208726</a></li>
</ul>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2020/02/03/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/" class="next">NEXT</a></div><div class="copyright"><p>© 2020 <a href="https://drea1v1.github.io">Drea1v1</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>