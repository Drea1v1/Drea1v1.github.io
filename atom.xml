<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>认真学习的小白帽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://drea1v1.github.io/"/>
  <updated>2020-06-23T09:05:46.913Z</updated>
  <id>https://drea1v1.github.io/</id>
  
  <author>
    <name>Drea1v1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用友nc远程命令执行漏洞分析</title>
    <link href="https://drea1v1.github.io/2020/06/17/%E7%94%A8%E5%8F%8Bnc%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drea1v1.github.io/2020/06/17/%E7%94%A8%E5%8F%8Bnc%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-06-16T16:33:52.000Z</published>
    <updated>2020-06-23T09:05:46.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NC用友远程命令执行漏洞分析"><a href="#NC用友远程命令执行漏洞分析" class="headerlink" title="NC用友远程命令执行漏洞分析"></a>NC用友远程命令执行漏洞分析</h1><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>这个漏洞是<a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener"> 国家电网公司信息与网络安全重点实验室 </a>发现的，微信公众号做了简要分析，但是没有给出具体的poc。现在微信公众号已经将文章删除，但其他的安全公众号仍留有记录，看了一下分析过程，故想要跟着分析漏洞成因，编写poc，因此才有了这一篇分析文章。虽然此次漏洞公告上写的版本为NC6.5,但是实际上像较新版的1909 NCCloud(用友2018年11月发布的最新技术架构软件)等都是存在该漏洞的。</p><h2 id="0x01分析过程"><a href="#0x01分析过程" class="headerlink" title="0x01分析过程"></a>0x01分析过程</h2><h3 id="1-客户端分析"><a href="#1-客户端分析" class="headerlink" title="1.客户端分析"></a>1.客户端分析</h3><p>访问<code>http://ip:port/index.jsp</code>会提示有两种方法登录系统，一种是通过下载客户端、一种是使用浏览器访问。因为，浏览器访问的方式需要依赖不同用户设备上的java版本，IE浏览器，系统配置等环境因素，使用起来不是很方便，所以为了解决这些问题，用友提供了系统专用的UClient浏览器，可直接通过该浏览器访问nc而无需安装配置任意东西。</p><p><img src="/images/YonyouNc/1592135084333.png" alt="1592135084333"></p><p>下载NClient并安装后，进入启动页面，可以选择<strong><u>添加应用</u></strong>。添加完后，在安装目录中可以看到所安装的应用。</p><p><img src="/images/YonyouNc/1592135683158.png" alt="1592135683158"></p><p><img src="/images/YonyouNc/1592135763897.png" alt="1592135763897"></p><p>点击app.esc发现直接启动了nc客户端，查看文件内容，发现执行了NClogin65.jar文件中的nc.starter.test.JStarter：</p><p><img src="/images/YonyouNc/1592136037372.png" alt="1592136037372"></p><p>反编译NClogin65.jar，查看nc.starter.test.JStarter，调用nc.starter.ui.NCLauncher#main主要是与远程服务端通信，生成uI之类的操作。主要的通信代码并不在该jar包，继续在目录中寻找。</p><p><img src="/images/YonyouNc/1592136244643.png" alt="1592136244643"></p><p><img src="/images/YonyouNc/1592136335295.png" alt="1592136335295"></p><p>在nc_client_home\NCCACHE\CODE目录的子目录中有很多的jar包，其中external目录上的jar包是客户端通信的逻辑代码。</p><p><img src="/images/YonyouNc/1592136581135.png" alt="1592136581135"></p><p>随便点了一两个包，发现类还不少，如果逐个看的话很耗费时间，效率还不高，看了分析的文章发现用javaagent把调用的类都打印出来的方法可以解决这个问题，具体原理感兴趣的可以去网上搜索相关的文章，具体可以代码可以参考<a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">javaagent项目中使用</a>。</p><p>之前在app.esc文件中可以看到启动jar的jvm配置信息，加上我们的javaagent的jar包，这样才能正常加载自己的javaagent。</p><p><img src="/images/YonyouNc/1592137794616.png" alt="1592137794616"></p><p>启动后可以看到把所有调用的类都输出出来了。</p><p><img src="/images/YonyouNc/1592137667520.png" alt="1592137667520"></p><p>这里可以配合idea的远程调试，添加参数jdwp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,address&#x3D;8000</span><br></pre></td></tr></table></figure><p><img src="/images/YonyouNc/1592151755174.png" alt="1592151755174"></p><p>打开客户端，随便输入账号密码点击登录后，查看log可以看到有login字眼的类：</p><p><img src="/images/YonyouNc/1592151973097.png" alt="1592151973097"></p><p>找到对应的nc.login.ui.LoginUISupport类，这个类方法很多，我一开始想的是通过一般登录都是带有request，response的，所以我就搜了request的关键字，在一个看起来比较像处理登录请求的方法下了断点，点击登录后果然是在这个地方断下来了。该方法主要是将输入的用户名、密码等值，在requestd类的变量赋值。</p><p><img src="/images/YonyouNc/1592152447890.png" alt="1592152447890"></p><p>执行getInstance(),获取NCLocator的实例，并执行实例的lookup方法。</p><p><img src="/images/YonyouNc/1592203909575.png" alt="1592203909575"></p><p>跟进<code>nc.bs.framework.common.NCLocator#getInstance(java.util.Properties)</code></p><p><img src="/images/YonyouNc/1592204019467.png" alt="1592204019467"></p><p>刚启动的时候locatorMap为空，则会在下面的判断分支中，创建RmiNCLocator实例并将该实例存放到locatorMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">locator = (NCLocator)locatorMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (locator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(locatorProvider)) &#123;</span><br><span class="line">                locator = newInstance(locatorProvider);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isEmpty(svcDispatchURL)) &#123;</span><br><span class="line">                locator = newInstance(<span class="string">"nc.bs.framework.rmi.RmiNCLocator"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                locator = getDefaultLocator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            locator.init(props);</span><br><span class="line">            locatorMap.put(key, locator);</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取到RmiNCLocator实例后，跟进到lookup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RmiNCLocator#lookup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> ComponentException </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.remoteContext.lookup(name);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var4 <span class="keyword">instanceof</span> FrameworkRuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (FrameworkRuntimeException)var4;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentException(name, <span class="string">"Component resolve exception "</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用了<code>this.remoteContext.lookup(name);</code>,继续跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteContextStub#lookup</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object so = <span class="keyword">this</span>.proxyMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> so;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ComponentMetaVO metaVO = <span class="keyword">this</span>.getMetaOnDemand(name);</span><br><span class="line">            <span class="keyword">if</span> (metaVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentNotFoundException(name, <span class="string">"no remote componnet found from server"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                so = <span class="keyword">this</span>.proxyMap.get(metaVO.getName());</span><br><span class="line">                <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    RemoteAddressSelector ras = <span class="keyword">new</span> GroupBasedRemoteAddressSelector(<span class="keyword">this</span>.getRealTarget(metaVO), <span class="keyword">this</span>.getServerGroup(metaVO));</span><br><span class="line">                    so = RemoteProxyFactory.getDefault().createRemoteProxy(RemoteContextStub<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">metaVO</span>, <span class="title">ras</span>)</span>;</span><br><span class="line">                    <span class="keyword">this</span>.proxyMap.put(metaVO.getName(), so);</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到先从proxyMap中查看是否存在参数name的方法，如果存在则直接返回，不存在则进入另外的分支。因为这里我是刚启动的，所以该方法是不存在的，也可以直接将so赋值为null，进去到下面的分支去看看具体的执行流程。</p><p><img src="/images/YonyouNc/1592209159419.png" alt="1592209159419"></p><p>跟进<code>nc.bs.framework.rmi.RemoteContextStub#getMetaOnDemand</code>,又可以看到调用了<code>this.remoteMetaContext.lookup(name);</code>方法，这个变量remoteMetaContext是<code>nc.bs.framework.server.RemoteMetaContext</code>类，那么这个类是怎么来的呢？</p><p><img src="/images/YonyouNc/1592209487982.png" alt="1592209487982"></p><p>因为当前的类为<code>nc.bs.framework.rmi.RemoteContextStub#RemoteContextStub</code>，这里可以回到类构造函数，第65行创建了一个代理，并赋值到<code>this.remoteMetaContext</code>：</p><p><img src="/images/YonyouNc/1592212049147.png" alt="1592212049147"></p><p>了解过java代理的应该知道，不管用户调用代理对象的任何方法，该方法都会调用处理器的invoke方法，这里即是<code>nc.bs.framework.rmi.RemoteInvocationHandler#invoke</code>。不懂的可以先看<a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">这里</a>。</p><p><img src="/images/YonyouNc/1592217600559.png" alt="1592217600559"></p><p>那么现在回到上面，跟进<code>this.remoteMetaContext.lookup(name);</code>，果然进入到了invoke方法。经过一番判断</p><p>执行this.sendRequest(method, args)方法。</p><p><img src="/images/YonyouNc/1592218223159.png" alt="1592218223159"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteInvocationHandler#sendRequest(java.lang.reflect.Method, java.lang.Object[])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        InvocationInfo ii = <span class="keyword">this</span>.newInvocationInfo(method, args);</span><br><span class="line">        Address old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        ConnectorFailException error = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Address target = <span class="keyword">this</span>.ras.select();</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logger.error(<span class="string">"connect to: "</span> + old + <span class="string">" failed, now retry connect to: "</span> + target);</span><br><span class="line">                <span class="keyword">if</span> (old.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">this</span>.retryInterval);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.restoreToken(ii, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var8 = <span class="keyword">this</span>.sendRequest(target, ii, method, args);</span><br><span class="line">                <span class="keyword">return</span> var8;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectorFailException var14) &#123;</span><br><span class="line">                ++retry;</span><br><span class="line">                old = target;</span><br><span class="line">                error = var14;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.storeToken(ii, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(retry &lt; <span class="keyword">this</span>.retryMax);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>this.sendRequest(target, ii, method, args);</code>,在第182行将ii序列化输出，发送到<code>http://server:port/ServiceDispatcherServlet</code>，并获取服务端返回的结果反序列化，回显到客户端。</p><p><img src="/images/YonyouNc/1592219243047.png" alt="1592219243047"></p><p><img src="/images/YonyouNc/1592219210083.png" alt="1592219210083"></p><p>到此客户端的处理流程大致分析完成，看到这里大家可能有会对上面客户端将类序列化发往服务端，那服务端肯定要反序列化呀，会不会有问题？别急，继续往下看。</p><h3 id="2-服务端分析"><a href="#2-服务端分析" class="headerlink" title="2.服务端分析"></a>2.服务端分析</h3><p>先来分析jndi注入的形成</p><p>在<code>nc.bs.framework.comn.serv.CommonServletDispatcher#doPost</code>第38行下断点。</p><p><img src="/images/YonyouNc/1592236432591.png" alt="1592236432591"></p><p>跟进<code>this.rmiHandler.handle(new HttpRMIContext(request, response));</code>,跟进后在第85行继续跟进<code>this.doHandle(rmiCtx);</code>。</p><p><img src="/images/YonyouNc/1592236486535.png" alt="1592236486535"></p><p>在第153行出现处理客户端提交内容的，继续跟进：</p><p><img src="/images/YonyouNc/1592236605328.png" alt="1592236605328"></p><p>在第282行可以看到直接将输入流的内容反序列化了，代码执行过程中完全没有任何的过滤，确实存在触发反序列化漏洞，这里先不管，继续往下。</p><p><img src="/images/YonyouNc/1592236746588.png" alt="1592236746588"></p><p>这里注意的是第286行将反序列化后的类赋予到抽象类<code>nc.bs.framework.rmi.server.AbstractRMIContext#invInfo</code>的invInfo变量里，这个变量在下面用到。</p><p><img src="/images/YonyouNc/1592220689757.png" alt="1592220689757"></p><p>回到刚才的第二个断点，跟进<code>result.result = this.invokeBeanMethod(rmiCtx);</code>,这里第333行就是上面说到的invinfo变量，实际就是反序列化后的类。</p><p>这里有两个分支，不管是哪个都存在jndi注入，因为这里lookup的参数service是可控的，所以必然存在漏洞。</p><p><img src="/images/YonyouNc/1592320624956.png" alt="1592320624956"></p><h3 id="3-效果演示"><a href="#3-效果演示" class="headerlink" title="3.效果演示"></a>3.效果演示</h3><p>这里就不给poc了，如果看懂了上面的过程其实也不难，实际就是构造一个InvocationInfo类，并将servicename的值设置为远程恶意类，序列化后发送到服务端触发jndi注入即可。</p><p><img src="/images/YonyouNc/1592322620367.png" alt="1592322620367"></p><p><img src="/images/YonyouNc/image-20200617093259154.png" alt="image-20200617093259154"></p><p><img src="/images/YonyouNc/1592323482077.png" alt="1592323482077"></p><h3 id="4-前面的反序列化"><a href="#4-前面的反序列化" class="headerlink" title="4.前面的反序列化"></a>4.前面的反序列化</h3><p>上面发现的反序列化根本都没有过滤的，为啥还要这么麻烦要jndi注入呢，直接反序列化不香嘛？看了web的依赖环境，commons-collections3.2，那不是现成的利用嘛。</p><p><img src="/images/YonyouNc/image-20200617105253981.png" alt="image-20200617105253981"></p><p>直接ysoserial生成恶意类发送，弹计算器。</p><p><img src="/images/YonyouNc/1592236873117.png" alt="1592236873117"></p><p>整个调用栈如下:</p><p><img src="/images/YonyouNc/image-20200617105315331.png" alt="image-20200617105315331"></p><p>注：在NCCloud 1909的版本中该依赖包为较新版，此利用链不可用。</p><h2 id="0X02-最后说几句"><a href="#0X02-最后说几句" class="headerlink" title="0X02 最后说几句"></a>0X02 最后说几句</h2><p>漏洞过程并不是太复杂，应该不难理解的。实际上，用友NC系统多处存在未过滤的反序列化漏洞，不过由于新版NC将依赖版本更新了，yso的大多数利用链都不能使用了,因此需要重新寻找新的利用链。</p><h2 id="0X03参考链接"><a href="#0X03参考链接" class="headerlink" title="0X03参考链接"></a>0X03参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA</a> </li><li><a href="https://nosec.org/home/detail/4472.html" target="_blank" rel="noopener">https://nosec.org/home/detail/4472.html</a></li><li><a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">https://www.cnblogs.com/Java-Script/p/11089314.html</a></li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a></li><li><a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3971367.html</a></li><li><a href="https://www.anquanke.com/post/id/208726" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208726</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NC用友远程命令执行漏洞分析&quot;&gt;&lt;a href=&quot;#NC用友远程命令执行漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;NC用友远程命令执行漏洞分析&quot;&gt;&lt;/a&gt;NC用友远程命令执行漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apereo CAS 4.X反序列化漏洞分析及复现</title>
    <link href="https://drea1v1.github.io/2020/02/03/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <id>https://drea1v1.github.io/2020/02/03/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-02-03T08:01:17.000Z</published>
    <updated>2020-02-04T04:48:56.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>放假前看到很多文章对这个漏洞进行分析复现，又因为过年期间的特殊情况，实在是无聊至极，所以自己也来学习一下，顺便恶补一下反序列化漏洞的知识。这篇文章记录了自己的一些想法以及相关的知识点，方便自己日后忘记可以重新拾起。第一次写文章有不好的，希望大家见谅。</p><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>由于部分cas版本的加密函数不同有相应的变化，因此想要按照此文章来复现漏洞的话还是选择和我一样的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk8u144(不一定完全一样)</span><br><span class="line">ApereoCas-4.1.5</span><br></pre></td></tr></table></figure><hr><blockquote><p>下载CAS-Overlay-Template</p></blockquote><p>github链接(<a href="https://github.com/apereo/cas-overlay-template/tree/4.1" target="_blank" rel="noopener">https://github.com/apereo/cas-overlay-template/tree/4.1</a>)</p><p>github上有详细的部署操作，这里要注意要修改pom.xml文件cas的版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cas.version&gt;4.1.5&lt;&#x2F;cas.version&gt;</span><br></pre></td></tr></table></figure><p>编译完后，会在target目录生成一个cas.war的war包，将该war包放在tomcat的web目录上，启动tomcat即可通过<a href="http://localhost/cas" target="_blank" rel="noopener">http://localhost/cas</a>访问example。</p><p>成功部署后：<br><img src="/images/ApereoCas/1.jpg" alt="image"></p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>该漏洞存在于登录的execution参数，抓包发现该参数值应该是加密过的，故要知道对应的加密方法以及处理过程才行。</p><p><img src="/images/ApereoCas/2.jpg" alt="image"></p><blockquote><p>web.xml</p></blockquote><p>查看登录url对应的servlet可知道交给了Spring的DispatcherServlet处理了，配置文件为/WEB-INF/cas-servlet.xml<br><img src="/images/ApereoCas/3.jpg" alt="image"></p><p>从springmvc的执行流程图(网上找的)可以知道只要找到对应的处理器适配器，就能找到对应的处理器。<br><img src="/images/ApereoCas/4.jpg" alt="image"></p><blockquote><p>cas-servlet.xml</p></blockquote><p>全局搜索login字眼，看到loginHandlerAdapter适配器，处理器的类名为org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter</p><p><img src="/images/ApereoCas/5.jpg" alt="image"></p><p>org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter该类继承FlowHandlerAdapter类，登录时调用继承类的handler方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter#handle</span><br><span class="line"></span><br><span class="line">public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        FlowHandler flowHandler &#x3D; (FlowHandler)handler;</span><br><span class="line">        this.checkAndPrepare(request, response, false);</span><br><span class="line">        String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br><span class="line">        if (flowExecutionKey !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.resumeExecution(flowExecutionKey, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var11) &#123;</span><br><span class="line">                this.handleFlowException(var11, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String flowId &#x3D; this.getFlowId(flowHandler, request);</span><br><span class="line">                MutableAttributeMap&lt;Object&gt; input &#x3D; this.getInputMap(flowHandler, request);</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.launchExecution(flowId, input, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var10) &#123;</span><br><span class="line">                this.handleFlowException(var10, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中flowExecutionKey通过getFlowExecutionKey方法获取参数execution的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br></pre></td></tr></table></figure><p>flowExecutionKey作为参数传入resumeExecution方法，跟进函数。在第91行对flowExecutionKey值的格式进行判断，通过”-“分割字符串为两部分uuid以及base64编码flowstate，因此格式不满足的话是无法继续走下去的。</p><p><img src="/images/ApereoCas/6.jpg" alt="image"></p><p><img src="/images/ApereoCas/7.jpg" alt="image"></p><p>跟进第96行getFlowExecution。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public FlowExecution getFlowExecution(FlowExecutionKey key) throws FlowExecutionRepositoryException &#123;</span><br><span class="line">        if (!(key instanceof ClientFlowExecutionKey)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Expected instance of ClientFlowExecutionKey but got &quot; + key.getClass().getName());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte[] encoded &#x3D; ((ClientFlowExecutionKey)key).getData();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ClientFlowExecutionRepository.SerializedFlowExecutionState state &#x3D; (ClientFlowExecutionRepository.SerializedFlowExecutionState)this.transcoder.decode(encoded);</span><br><span class="line">                FlowDefinition flow &#x3D; this.flowDefinitionLocator.getFlowDefinition(state.getFlowId());</span><br><span class="line">                return this.flowExecutionFactory.restoreFlowExecution(state.getExecution(), flow, key, state.getConversationScope(), this.flowDefinitionLocator);</span><br><span class="line">            &#125; catch (IOException var5) &#123;</span><br><span class="line">                throw new ClientFlowExecutionRepositoryException(&quot;Error decoding flow execution&quot;, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在第105行对之前base64解码后的encoded进行解密，跟进解密函数this.transcoder.decode(encoded)</p><p><img src="/images/ApereoCas/8.jpg" alt="image"></p><p><img src="/images/ApereoCas/9.jpg" alt="image"></p><p>可以看出在第83行对密文进行解密，经过一系列的操作后在99行进行反序列化，触发漏洞。可以看出调用的decode方法属于EncryptedTranscoder类，该类还定义的加密方法encode，这里可以直接生成恶意对象，直接调用org.jasig.spring.webflow.plugin.EncryptedTranscoder#encode生成加密字节数组后base64，加上”uuid-“构成execution的值。</p><blockquote><p>整个调用栈</p></blockquote><p><img src="/images/ApereoCas/10.jpg" alt="image"></p><h1 id="0x03-构造payload"><a href="#0x03-构造payload" class="headerlink" title="0x03 构造payload"></a>0x03 构造payload</h1><p>默认环境的jar包中有commons-collections4-4.0.jar，直接使用ysoserial生成payload,这里记得要将payload的特殊符号进行url编码。</p><p><img src="/images/ApereoCas/11.jpg" alt="image"></p><p><img src="/images/ApereoCas/12.jpg" alt="image"></p><blockquote><p>演示结果</p></blockquote><p>成功执行系统命令<br><img src="/images/ApereoCas/13.jpg" alt="image"></p><h1 id="0x04-构造回显payload"><a href="#0x04-构造回显payload" class="headerlink" title="0x04 构造回显payload"></a>0x04 构造回显payload</h1><p>看了大佬的<a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">分析</a>，知道可以回显，文章提及到org.springframework.webflow.context.ExternalContextHolder.getExternalContext()方法可以获取到上下文关联信息，然后通过getNativeRequest()方法获取request对象通过getNativeResponse()方法获取response对象。同时提及到org.springframework.cglib.core.ReflectUtils.defineClass().newInstance();加载payload。我的猜测大佬的想法是通过defineClass从byte[]还原出一个Class对象，该恶意对象主要是执行命令，获取response对象，将执行命令后的结果通过response对象的输出流输出。在利用commons-collections1是发现ReflectUtils利用不了，因为构造方法为private，要设置setAccessible为true。因此使用commons-collections2的话，实际就不需要这么麻烦用defineClass来加载payload了，直接在利用类里面写就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils</span><br><span class="line">private ReflectUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils#defineClass</span><br><span class="line"></span><br><span class="line"> public static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception &#123;</span><br><span class="line">        Object[] args &#x3D; new Object[]&#123;className, b, new Integer(0), new Integer(b.length), PROTECTION_DOMAIN&#125;;</span><br><span class="line">        Class c &#x3D; (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">        Class.forName(className, true, loader);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里看看ysoserial的commons-collections2的构造恶意对象的主要方法。这里使用javassist,第66行获取要操作的类，第75行在该类的构造方法中插入代码,因此这里只要修改该类ysoserial.payloads.util.Gadgets.StubTransletPayload的构造方法为执行系统命令，并修改response的输出流。大家可以直接修改ysoserial的源码并重新编译，我这里为了方便直接用了网上的payload改了一下。</p><p><img src="/images/ApereoCas/14.jpg" alt="image"></p><p><img src="/images/ApereoCas/15.jpg" alt="image"></p><blockquote><p>演示结果</p></blockquote><p><img src="/images/ApereoCas/16.jpg" alt="image"></p><h1 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h1><p>文章中存在错误的地方希望大佬们斧正，多多指点。通过这次的分析，其实学到很多东西的，包括commons-collections利用链、ysoserial(这个工具，也是边看别人的分析，边看的源码，不然一脸懵逼)。最后，在新的一年里希望大家身体健康，万事如意。</p><h1 id="0x05参考链接："><a href="#0x05参考链接：" class="headerlink" title="0x05参考链接："></a>0x05参考链接：</h1><p><a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">https://www.00theway.org/2020/01/04/apereo-cas-rce/</a></p><p><a href="https://xz.aliyun.com/t/2041" target="_blank" rel="noopener">https://xz.aliyun.com/t/2041</a></p><p><a href="https://xz.aliyun.com/t/4711" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711</a></p><p><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">https://xz.aliyun.com/t/7031</a></p><p><a href="https://xz.aliyun.com/t/7032" target="_blank" rel="noopener">https://xz.aliyun.com/t/7032</a></p><p><a href="http://www.vuln.cn/6295" target="_blank" rel="noopener">http://www.vuln.cn/6295</a></p><p><a href="https://www.freebuf.com/vuls/170344.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/170344.html</a></p><p><a href="https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA</a></p><p><a href="https://www.cnblogs.com/gxc6/p/9544563.html" target="_blank" rel="noopener">https://www.cnblogs.com/gxc6/p/9544563.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;放假前看到很多文章对这个漏洞进行分析复现，又因为过年期间的特殊情况，实在是无聊至极，所以自己也来学习
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="https://drea1v1.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
